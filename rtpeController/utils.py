import random
import string
import bencodepy
import socket
import subprocess
import sdp_transform
import json
import os
import time
from pprint import pprint
from websocket import create_connection, enableTrace

bc = bencodepy.Bencode(
    encoding='utf-8'
)


def gen_cookie(length):
    """ Genarate a random for cookie. 

    Args:
        length: Length of the desired random string.

    Returns:
        A string with a given length made of random ASCII lowercase
        characters.
    """
    return ''.join(random.choice(string.ascii_lowercase) for i in range(length))

def random_with_N_digits(n):
    ''' Generate a random with n digits. 

    Args:
        n: Len of digits.

    Returns:
        An int with n digits.
    '''
    range_start = 10**(n-1)
    range_end = (10**n)-1
    return random.randint(range_start, range_end)

def send(address, port, file, bind_address, bind_port):
    """ Send a JSON file to RTPengine on the given ports.

    Args:
        address: RTPengine server IPv4 address. 
        port: RTPengine server port.
        file: A dictionary which describes the RTPengine ng commands.
        bind_address: Source IPv4 address. 
        bind_port: Source port. 

    Returns:
        An object containing the RTPengine response. 
    """

    # Generate and send ng message
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if bind_address != '127.0.0.1':
        sock.bind((bind_address, bind_port))
    
    sock.settimeout(10)

    cookie = gen_cookie(5)
    data = bencodepy.encode(file).decode()
    message = str(cookie) + " " + str(data)
    sock.sendto(message.encode('utf-8'), (address, port))
    try:
        response = sock.recv(4096)
    except Exception:
        print("Did not received a response!")
        return {}
    data = response.decode()
    data = data.split(" ", 1)
    result = bc.decode(data[1])

    sock.close()

    return result

def ws_send(address, port, file, **kwargs):
    """ Send a JSON file to RTPengine on the given port with via ws

    Args:
        address: RTPengine server websocket address.
        port: RTPengine server port. 
        file: A dictionary which describes the RTPengine commands.
        kwargs:
            bind_address: Source address. 
            bind_port: Source port.
            delay: Delay before send back
            sock: Predefined socket. 

    Returns:
        An object containing the RTPengine response.
    """

    bind_address = kwargs.get('bind_address', '127.0.0.1')
    bind_port = kwargs.get('bind_port', 2001)
    delay = kwargs.get('delay', 0)
    ws_sock = kwargs.get('sock', None)
    response = None

    cookie = gen_cookie(5)
    data = bencodepy.encode(file).decode()
    message = str(cookie) + " " + str(data)

    if not ws_sock:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if bind_address != '127.0.0.1':
            sock.bind((bind_address, bind_port))
        sock.connect((address, port))
        
        # enableTrace(True)
        ws = create_connection(
            f'ws://{address}:{port}', 
            subprotocols=["ng.rtpengine.com"],
            origin=bind_address,
            socket=sock
        )

        time.sleep(delay)
        ws.send(message)
        response = ws.recv()

        ws.close()
        sock.close()
    else:
        time.sleep(delay)
        ws_sock.send(message)
        response = ws_sock.recv()

    print("response: " + str(response))
    if response != '':
        data = response.decode()
        if os.getenv('RTPE_CONTROLLER'):
            data = data.split(" ", 1)
            return bc.decode(data[1])
        else:
            return bc.decode(data)
    else: 
        print("No data received")
        return ""

def ffmpeg(audio_file, cnt, offer_rtp_address, answer_rtp_address, codecs):
    """ Send RTP traffic to a given address with ffmpeg.

    With ffmpeg you can control how the media stream should be send
    out. For example you can change the codec if it is needed. 

    Args:
        audio_file: Path of the audio file.
        cnt: How many streams should be generated by ffmpeg. 
        offer_rtp_address: A list of rtp addresses with the offer port.
        answer_rtp_address: 
            A list of answer addresses with the answer port. 
    """

    codecs_alphabet = []
    for c in codecs:
        if c == '0':
            codecs_alphabet.append('pcm_mulaw')
        else:
            codecs_alphabet.append('gsm')

    processes = []
    for c in range(cnt):
        processes.append(
          subprocess.Popen(
            ["ffmpeg", "-re", "-i", audio_file, "-ar", "8000", "-ac", "1",
            "-acodec", codecs_alphabet[0], "-f", "rtp", offer_rtp_address[c]
            ]
          )
        )
        processes.append(
          subprocess.Popen(
              ["ffmpeg", "-re", "-i", audio_file, "-ar", "8000", "-ac", "1",
              "-acodec", codecs_alphabet[1], "-f", "rtp", answer_rtp_address[c]
              ]
          )
        )

    # Close the processes
    print('# of processes: ' + str(len(processes)))
    for process in processes:
        process.communicate()

def rtpsend(dump_file, cnt, caller_source_ports, caller_destinations,
    callee_source_ports, callee_destinations):
    processes = []
    for c in range(cnt):
        processes.append(
            subprocess.Popen(
                ["rtpsend", "-l", "-s", caller_source_ports[c], "-f", 
                dump_file, caller_destinations[c]]
            )
        )

        processes.append(
            subprocess.Popen(
                ["rtpsend", "-l", "-s", callee_source_ports[c], "-f",
                dump_file, callee_destinations[c]]
            )
        )

    # Close proccesses
    for process in processes:
        process.communicate()

def handle_oa(address, port, file, bind, type, ws=False):
    ''' Send an offer or answer. 

    Args:
        address: RTPengine address.
        port: RTPengine port.
        file: Location of the offer or answer.
        bind: List with an IP and Port for source.
        type: "offer" or "answer"

    Returns:
        RTP port given by RTPengine.
    '''
    
    with open(file) as f:
        command = json.load(f)
    if ws:
        response = ws_send(address, port, command, bind_address=bind[0], bind_port=int(bind[1]))
    else:
        response = send(address, port, command, bind[0], int(bind[1]))
    parsed_sdp_dict = sdp_transform.parse(response.get('sdp'))
    rtp_port = parsed_sdp_dict.get('media')[0].get('port')
    rtcp_port = parsed_sdp_dict.get('media')[0].get('rtcp').get('port')
    print(f'RTP port from {type}: {rtp_port}')
    print(f'RTCP port from {type}: {rtcp_port}')
    return rtp_port

def generate_sdp(address, port, **kwargs):
    ''' Generate a basic sdp message.

    Will use PCMU.

    Args:
        address: The sender address.
        port: The sender local port.

    Returns:
        A string which contain the sdp message.
    '''

    sdp = {
        'version': 0,
        'origin': {
            'address': address,
            'ipVer': 4,
            'netType': 'IN',
            'sessionId': random_with_N_digits(10),
            'sessionVersion': 1,
            'username': '-'
        },
        'name': 'tester',
        'timing': {'start': 0, 'stop': 0},
        'media': [
            {
                'connection': {'ip': address, 'version': 4},
                'direction': 'sendrecv',
                'fmtp': [],
                'payloads': kwargs['payload'],
                'port': port,
                'protocol': 'RTP/AVP',
                'rtp': [],
                'type': 'audio'
            }
        ]
    }

    return sdp_transform.write(sdp)